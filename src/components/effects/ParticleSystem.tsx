import React, { useEffect, useRef, useState } from 'react';\nimport { motion } from 'framer-motion';\n\ninterface Particle {\n  id: number;\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  opacity: number;\n  color: string;\n  life: number;\n  maxLife: number;\n}\n\ninterface ParticleSystemProps {\n  count?: number;\n  variant?: 'floating' | 'burst' | 'trail' | 'ambient' | 'interactive';\n  color?: string;\n  intensity?: 'low' | 'medium' | 'high';\n  className?: string;\n  trigger?: boolean;\n}\n\nconst ParticleSystem: React.FC<ParticleSystemProps> = ({\n  count = 20,\n  variant = 'floating',\n  color = '#6366f1',\n  intensity = 'medium',\n  className = '',\n  trigger = false\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationRef = useRef<number>();\n  const particlesRef = useRef<Particle[]>([]);\n  const [isActive, setIsActive] = useState(true);\n\n  const intensityConfig = {\n    low: { speed: 0.5, opacity: 0.3, count: count * 0.5 },\n    medium: { speed: 1, opacity: 0.6, count },\n    high: { speed: 2, opacity: 0.8, count: count * 1.5 }\n  };\n\n  const config = intensityConfig[intensity];\n\n  const createParticle = (x?: number, y?: number): Particle => {\n    const canvas = canvasRef.current;\n    if (!canvas) return {} as Particle;\n\n    const colors = [\n      color,\n      '#8b5cf6',\n      '#3b82f6',\n      '#06b6d4',\n      '#10b981'\n    ];\n\n    return {\n      id: Math.random(),\n      x: x ?? Math.random() * canvas.width,\n      y: y ?? Math.random() * canvas.height,\n      vx: (Math.random() - 0.5) * config.speed,\n      vy: (Math.random() - 0.5) * config.speed,\n      size: Math.random() * 4 + 1,\n      opacity: Math.random() * config.opacity,\n      color: colors[Math.floor(Math.random() * colors.length)],\n      life: 0,\n      maxLife: 100 + Math.random() * 200\n    };\n  };\n\n  const initParticles = () => {\n    particlesRef.current = [];\n    for (let i = 0; i < config.count; i++) {\n      particlesRef.current.push(createParticle());\n    }\n  };\n\n  const updateParticle = (particle: Particle, canvas: HTMLCanvasElement) => {\n    particle.life++;\n    \n    if (variant === 'floating') {\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      particle.vy += 0.01; // Slight gravity\n      \n      // Bounce off walls\n      if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -0.8;\n      if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -0.8;\n      \n      // Keep in bounds\n      particle.x = Math.max(0, Math.min(canvas.width, particle.x));\n      particle.y = Math.max(0, Math.min(canvas.height, particle.y));\n    }\n    \n    if (variant === 'burst') {\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      particle.vx *= 0.99;\n      particle.vy *= 0.99;\n      particle.vy += 0.02;\n    }\n    \n    if (variant === 'trail') {\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      particle.opacity *= 0.99;\n    }\n    \n    if (variant === 'ambient') {\n      particle.x += Math.sin(particle.life * 0.01) * 0.5;\n      particle.y += Math.cos(particle.life * 0.01) * 0.3;\n      particle.opacity = Math.sin(particle.life * 0.02) * 0.5 + 0.5;\n    }\n    \n    // Fade out near end of life\n    if (particle.life > particle.maxLife * 0.8) {\n      particle.opacity *= 0.95;\n    }\n    \n    return particle.life < particle.maxLife && particle.opacity > 0.01;\n  };\n\n  const drawParticle = (ctx: CanvasRenderingContext2D, particle: Particle) => {\n    ctx.save();\n    \n    // Create gradient for particle\n    const gradient = ctx.createRadialGradient(\n      particle.x, particle.y, 0,\n      particle.x, particle.y, particle.size\n    );\n    gradient.addColorStop(0, `${particle.color}${Math.floor(particle.opacity * 255).toString(16).padStart(2, '0')}`);\n    gradient.addColorStop(1, `${particle.color}00`);\n    \n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Add glow effect\n    if (intensity === 'high') {\n      ctx.shadowColor = particle.color;\n      ctx.shadowBlur = particle.size * 2;\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    ctx.restore();\n  };\n\n  const animate = () => {\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext('2d');\n    if (!canvas || !ctx) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Update and draw particles\n    particlesRef.current = particlesRef.current.filter(particle => {\n      const isAlive = updateParticle(particle, canvas);\n      if (isAlive) {\n        drawParticle(ctx, particle);\n      }\n      return isAlive;\n    });\n    \n    // Add new particles if needed\n    if (particlesRef.current.length < config.count && isActive) {\n      particlesRef.current.push(createParticle());\n    }\n    \n    // Continue animation\n    if (isActive) {\n      animationRef.current = requestAnimationFrame(animate);\n    }\n  };\n\n  const handleTrigger = () => {\n    if (variant === 'burst') {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      \n      const centerX = canvas.width / 2;\n      const centerY = canvas.height / 2;\n      \n      for (let i = 0; i < 20; i++) {\n        const angle = (i / 20) * Math.PI * 2;\n        const speed = 2 + Math.random() * 3;\n        const particle = createParticle(centerX, centerY);\n        particle.vx = Math.cos(angle) * speed;\n        particle.vy = Math.sin(angle) * speed;\n        particlesRef.current.push(particle);\n      }\n    }\n  };\n\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (variant === 'interactive') {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      \n      const rect = canvas.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      \n      // Add particles around mouse\n      for (let i = 0; i < 3; i++) {\n        const particle = createParticle(\n          x + (Math.random() - 0.5) * 20,\n          y + (Math.random() - 0.5) * 20\n        );\n        particle.maxLife = 50;\n        particlesRef.current.push(particle);\n      }\n    }\n  };\n\n  const resizeCanvas = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const rect = canvas.getBoundingClientRect();\n    canvas.width = rect.width * window.devicePixelRatio;\n    canvas.height = rect.height * window.devicePixelRatio;\n    \n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n    }\n  };\n\n  useEffect(() => {\n    resizeCanvas();\n    initParticles();\n    \n    const handleResize = () => resizeCanvas();\n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    if (isActive) {\n      animate();\n    } else {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    }\n    \n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [isActive, config]);\n\n  useEffect(() => {\n    if (trigger) {\n      handleTrigger();\n    }\n  }, [trigger]);\n\n  return (\n    <motion.canvas\n      ref={canvasRef}\n      className={`absolute inset-0 pointer-events-none ${className}`}\n      onMouseMove={variant === 'interactive' ? handleMouseMove : undefined}\n      style={{\n        pointerEvents: variant === 'interactive' ? 'auto' : 'none'\n      }}\n      initial={{ opacity: 0 }}\n      animate={{ opacity: isActive ? 1 : 0 }}\n      transition={{ duration: 0.5 }}\n    />\n  );\n};\n\nexport default ParticleSystem;